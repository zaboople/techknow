<!DOCTYPE html>
<html>
    <head>
    <meta charset="UTF-8" />
    <title>Hello World</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        div#clops{padding:0px;margin:0px;font-size:7px;}
    </style>

    </head>
    <body>
        <div id="root"></div>

        <!--
            Shows how to assign events in JSX, AND how to manage re-renderable state.
        -->
        <script type="text/jsx">

            function MyPage() {
                console.log("Re-do page")

                // I'm doing state variables. This is the magical magic that
                // makes React re-render my HTML to account for state updates:
                // Top buttons click counts:
                const [nameCounts, setNameCounts]=React.useState({});
                const [clicks, setTotalClicks]   =React.useState(0);
                // Bottom "clop" button:
                const [clipclops, setClopsArray]        =React.useState([]);
                const [clopKey, setClopKey]      =React.useState(0);


                // This is for the upper part, where we just count
                // individual & total button clicks:
                function updateCounts(name) {
                    // You might think it's enough to update nameCounts directly
                    // and just pass it to setNameCounts() - wrong! React will
                    // just decide, "oh, nothing changed, okay," because it's
                    // the same *object* instead of a new object.
                    var newn = Object.assign({}, nameCounts);
                    var cc = newn[name]
                    if (!cc) cc = 0;
                    newn[name] = cc+1;
                    setNameCounts(newn)
                    setTotalClicks(clicks+1);
                }
                function getArrowUpdate(funco, name) {
                    // This is necessary because of how react evaluates things.
                    // I can't do "{updateCounts(name)}" in my HTML because react
                    // will just call updateCounts(name) once at render time. So
                    // instead I'm dropping in an arrow function... With a
                    // parameterless function, you would just put "{funcname}"
                    // without parentheses, so that you're giving React a function
                    // *reference*, not a text attribute with a function call in the
                    // text; that's effectively what I'm doing here as well:
                    return ()=>funco(name)
                }


                // This is for the lower part, where we scroll clop-clops
                function clickClop() {
                    // Holy crap! What is this horror? We're generating HTML on the fly!
                    // We are actually storing an array of divs using React's usestate
                    // and that same state is returned by GetClops(), and wackadoobeydoo.

                    // Makes an array of clop-clops, every other one in all-caps bold:
                    var htmlRay = Array.from(function*(){
                        var flipper = Math.floor(Math.random() * 2);
                        for (var i = Math.floor(Math.random() * 12) + 1;
                            i > 0; i--)
                            yield (
                                i % 2 == flipper
                                    ?(<b key={i}> CLOP CLOP </b>)
                                    :" clip clop "
                            );
                    }());

                    // Make a new array containing old state, and append
                    // another div. That div contains our latest bunch of
                    // random clip-clops:
                    const myray = [...clipclops]
                    if (myray.length > 45)
                        myray.shift();
                    const kk = clopKey+1;
                    myray.push(<div key={kk}>{htmlRay}</div>);
                    setClopKey(kk);
                    setClopsArray(myray);
                }
                function GetClops() {
                    console.log("GetClops()")
                    return clipclops;
                }


                // Render the whole thing into HTML:
                const names = [
                    'Fourteen', 'Doritos', 'Onion', 'Cat food', 'Moustachio'
                ];
                return (<>
                    <p>
                        Feel free to park focus on a button and then instruct your cat
                        to take a nap on the keyboard's Enter key:
                    </p>

                    <div>
                        <ul>
                            {names.map(name => (
                                <li key={name}>
                                    <button onClick={getArrowUpdate(updateCounts, name)}>
                                        {name}
                                    </button> {nameCounts[name]}
                                </li>
                            ))}
                        </ul>
                        Total clicks: {clicks}
                    </div>

                    <button onClick={clickClop}>Clop</button>
                    <div id="clops"><GetClops/></div>
                </>);
            }

            ReactDOM.createRoot(document.getElementById('root'))
                .render(<MyPage/>);
        </script>
    </body>
</html>